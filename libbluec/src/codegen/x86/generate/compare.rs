// Copyright 2025 Neil Henderson, Blue Tarp Media.
//
//! The `compare` module provides functionality to handle Cmp instructions, including quiet NaNs with floating-
//! point types.

use super::Generator;
use crate::codegen::x86::ast::{AsmBinaryOp, AsmInstruction, AsmOperand, AsmType, ConditionalCode};
use crate::codegen::x86::registers::HwRegister;

/// Generates the Cmp instruction to compare the given primitive (integer-type) operand with zero, and then calls
/// the given `and_then` closure to generate subsequent instructions which should test the comparison result and
/// perform an appropriate action.
///
/// The generated Cmp instruction uses the given `operand` as its second operand. E.g.
///
/// ```asm
/// cmp 0, operand  # In AT&T syntax, calculates 'operand minus 0'
/// ```
pub fn compare_with_zero_integer<F>(asm_type: AsmType, operand: &AsmOperand, and_then: F, out: &mut Vec<AsmInstruction>)
where
    F: FnOnce() -> Vec<AsmInstruction>,
{
    debug_assert!(asm_type.is_primitive());

    // cmp 0, operand
    out.push(AsmInstruction::Cmp { asm_type, op1: AsmOperand::from_u64(0), op2: operand.clone() });

    out.extend(and_then());
}

/// Generates the Cmp instruction to compare two operands of primitive (integer) type, and then calls the given
/// `and_then` closure to generate subsequent instructions which should test the comparison result and perform
/// an appropriate action.
///
/// The second operand is compared with the first by subtracting the first from the second. E.g.
///
/// ```asm
/// cmp op1, op2  # In AT&T syntax, calculates 'op2 minus op1'
/// ```
pub fn compare_2_operands_integer<F>(
    asm_type: AsmType,
    op1: &AsmOperand,
    op2: &AsmOperand,
    and_then: F,
    out: &mut Vec<AsmInstruction>,
) where
    F: FnOnce() -> Vec<AsmInstruction>,
{
    debug_assert!(asm_type.is_primitive());

    // cmp op1, op2
    out.push(AsmInstruction::Cmp { asm_type, op1: op1.clone(), op2: op2.clone() });

    out.extend(and_then());
}

/// Generates the Cmp instructions to compare the given floating-point operand with zero, and then calls the given
/// `and_then` closure to generate subsequent instructions which should test the comparison result and perform an
/// appropriate action.
///
/// If the Cmp sets the Parity Flag then the comparison result is a quiet NaN. The CPU will jump to the given code
/// generated by the `nan_handler` closure.
///
/// The generated Cmp instruction uses the given `operand` as its second operand. E.g.
///
/// ```asm
///   xorpd xmm0, xmm0   # xmm0 = 0.0
///   cmp xmm0, operand  # In AT&T syntax, calculates 'operand minus xmm0'
///   jp qnan            # If quiet NaN, jump to the nan handler
///   <and_then>         # Code generated by the 'and_then' closure
///   jmp end            # Jump to end
/// qnan:
///   <nan_handler>      # Code generated by the 'nan_handler' closure
/// end:
/// ```
pub fn compare_with_zero_fp<F1, F2>(
    asm_type: AsmType,
    operand: &AsmOperand,
    and_then: F1,
    nan_handler: F2,
    out: &mut Vec<AsmInstruction>,
    generator: &mut Generator,
) where
    F1: FnOnce() -> Vec<AsmInstruction>,
    F2: FnOnce() -> Vec<AsmInstruction>,
{
    debug_assert!(asm_type.is_floating_point());

    let end_label = generator.labels.make_function_local_label();
    let qnan_label = generator.labels.make_function_local_label();

    // xorpd xmm0, xmm0
    out.push(zero_out_xmm0(asm_type));

    // cmp xmm0, operand
    out.push(AsmInstruction::Cmp { asm_type, op1: AsmOperand::Reg(HwRegister::XMM0), op2: operand.clone() });

    // If Parity Flag is set, the result is a quiet NaN so jump to the qnan handler.
    // jp qnan_label
    out.push(AsmInstruction::JmpCC { cond_code: ConditionalCode::P, target: qnan_label.clone() });

    out.extend(and_then());

    // jmp end_label
    out.push(AsmInstruction::Jmp { target: end_label.clone() });

    // qnan_label:
    out.push(AsmInstruction::Label { id: qnan_label });

    out.extend(nan_handler());

    // end_label:
    out.push(AsmInstruction::Label { id: end_label });
}

/// Generates the Cmp instructions to compare the two given floating-point operands, and then calls the given
/// `and_then` closure to generate subsequent instructions which should test the comparison result and perform an
/// appropriate action.
///
/// If the Cmp sets the Parity Flag then the comparison result is a quiet NaN. The CPU will jump to the given
/// code generated by the `nan_handler` closure.
///
/// The second operand is compared with the first by subtracting the first from the second. E.g.
///
/// ```asm
///   cmp op1, op2       # In AT&T syntax, calculates 'op2 minus op1'
///   jp qnan            # If quiet NaN, jump to the nan handler
///   <and_then>         # Code generated by the 'and_then' closure
///   jmp end            # Jump to end
/// qnan:
///   <nan_handler>      # Code generated by the 'nan_handler' closure
/// end:
/// ```
pub fn compare_2_operands_fp<F1, F2>(
    asm_type: AsmType,
    op1: &AsmOperand,
    op2: &AsmOperand,
    and_then: F1,
    nan_handler: F2,
    out: &mut Vec<AsmInstruction>,
    generator: &mut Generator,
) where
    F1: FnOnce() -> Vec<AsmInstruction>,
    F2: FnOnce() -> Vec<AsmInstruction>,
{
    debug_assert!(asm_type.is_floating_point());

    let end_label = generator.labels.make_function_local_label();
    let qnan_label = generator.labels.make_function_local_label();

    // cmp op1, op2
    out.push(AsmInstruction::Cmp { asm_type, op1: op1.clone(), op2: op2.clone() });

    // If Parity Flag is set, the result is a quiet NaN so jump to the qnan handler.
    // jp qnan_label
    out.push(AsmInstruction::JmpCC { cond_code: ConditionalCode::P, target: qnan_label.clone() });

    out.extend(and_then());

    // jmp end_label
    out.push(AsmInstruction::Jmp { target: end_label.clone() });

    // qnan_label:
    out.push(AsmInstruction::Label { id: qnan_label });

    out.extend(nan_handler());

    // end_label:
    out.push(AsmInstruction::Label { id: end_label });
}

fn zero_out_xmm0(asm_type: AsmType) -> AsmInstruction {
    let xmm0 = AsmOperand::Reg(HwRegister::XMM0);
    AsmInstruction::Binary { op: AsmBinaryOp::Xor, asm_type, src: xmm0.clone(), dst: xmm0 }
}
