// Copyright 2025-2026 Neil Henderson
//
//! The `tu_file` module defines [TuFile], which represents the preprocessed translation unit file.

use std::path::Path;

use crate::ICE;
use crate::core::{FilePosition, SourceLocation, TempFile};

/// A line marker and its location in the preprocessed translation unit file.
#[derive(Debug)]
struct LineMarker {
    /// The byte position in the preprocessed translation unit file.
    pub file_pos: FilePosition,

    /// The logical filename
    pub logical_filename: String,

    /// The logical line number
    pub logical_line_no: u32,
}

/// Represents the preprocessed translation unit file.
#[derive(Debug)]
pub struct TuFile {
    file_path: String,
    line_positions: Vec<FilePosition>,
    line_markers: Vec<LineMarker>,

    // Owns the temporary file
    _translation_unit_temp_file: TempFile,
}

impl TuFile {
    /// Creates a new `TuFile`.
    pub fn new(source_file_path: &str) -> Self {
        let (temp_file, file_path) = create_temp_file_path(source_file_path);

        Self {
            file_path: file_path.to_string(),
            line_positions: Vec::new(),
            line_markers: Vec::new(),
            _translation_unit_temp_file: temp_file,
        }
    }

    /// Creates a new `TuFile` for unit tests.
    #[cfg(test)]
    pub fn for_testing() -> Self {
        Self {
            file_path: String::new(),
            line_positions: Vec::new(),
            line_markers: Vec::new(),
            _translation_unit_temp_file: TempFile::none(),
        }
    }

    /// The path to the preprocessed translation unit file.
    pub fn file_path(&self) -> &String {
        &self.file_path
    }

    /// Records the file position where a new line begins (after the '\n' byte).
    pub fn add_line_start_pos(&mut self, file_pos: FilePosition) {
        self.line_positions.push(file_pos);
    }

    /// Adds a line marker.
    pub fn add_line_marker(&mut self, file_pos: FilePosition, file_name: &str, line_no: u32) {
        self.line_markers.push(LineMarker {
            file_pos,
            logical_filename: file_name.to_string(),
            logical_line_no: line_no,
        });
    }

    /// Gets the filename and 1-based line number for the given source location that should be displayed to the
    /// end-user.
    ///
    /// This function takes into account line markers generated by the preprocessor.
    pub fn get_filename_and_line_no(&self, source_loc: SourceLocation) -> (String, u32) {
        if self.line_markers.is_empty() {
            return (self.file_path.clone(), 1);
        }

        match self.line_markers.binary_search_by(|marker| marker.file_pos.cmp(&source_loc.file_pos)) {
            Ok(idx) => {
                // An exact match means we found a line marker directive
                let line_marker = &self.line_markers[idx];
                (line_marker.logical_filename.clone(), line_marker.logical_line_no)
            }

            Err(idx) => {
                // `idx` tells us where the value should be inserted, so the prior line marker is at idx-1.
                assert!(idx >= 1);
                let line_marker = &self.line_markers[idx - 1];

                // Determine how many newlines there are between the line marker file pos and the given source location
                // file pos, so that we can add this value to the logical line number from the line marker.
                let Ok(line_marker_line_idx) = self.line_positions.binary_search(&line_marker.file_pos) else {
                    ICE!("Did not find the line start position for the line marker");
                };

                let source_loc_line_idx = match self.line_positions.binary_search(&source_loc.file_pos) {
                    Ok(idx) => idx,
                    Err(idx) => idx - 1,
                };

                debug_assert!(source_loc_line_idx >= line_marker_line_idx);
                let offset = source_loc_line_idx - line_marker_line_idx;
                let line_no = line_marker.logical_line_no + offset as u32;

                (line_marker.logical_filename.clone(), line_no)
            }
        }
    }

    /// Gets the zero-based line number in the preprocessed translation unit file for the given file position.
    pub fn get_source_file_line_no(&self, file_pos: FilePosition) -> usize {
        match self.line_positions.binary_search(&file_pos) {
            Ok(idx) => idx,

            Err(idx) => {
                // `idx` tells us where the value should be inserted, so the line number is idx-1.
                assert!(idx >= 1);
                idx - 1
            }
        }
    }

    /// Gets the 1-based column number for the given source location.
    pub fn get_column_no(&self, source_loc: SourceLocation) -> u32 {
        match self.line_positions.binary_search(&source_loc.file_pos) {
            Ok(_) => {
                // An exact match means we found the start of the line, so this position is the first column (1-based).
                1
            }

            Err(idx) => {
                // `idx` tells us where the value should be inserted, so the line number is idx-1.
                assert!(idx >= 1);
                let line_start_pos = self.line_positions[idx - 1];
                let offset_from_line_start: u32 = (source_loc.file_pos - line_start_pos).into();
                offset_from_line_start + 1
            }
        }
    }
}

fn create_temp_file_path(source_filename: &str) -> (TempFile, String) {
    let temp_file_prefix = Path::new(source_filename).file_stem().unwrap_or_default().to_str().unwrap_or_default();

    let temp_file = TempFile::try_create(temp_file_prefix);
    if temp_file.is_none() {
        ICE!("Cannot create temporary file path");
    }

    let temp_file = temp_file.unwrap();
    let temp_file_path = temp_file.path_to_string();

    (temp_file, temp_file_path)
}
