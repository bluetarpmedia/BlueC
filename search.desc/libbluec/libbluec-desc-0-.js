searchState.loadedDescShard("libbluec", 0, "The BlueC library.\nGenerates an internal compiler error.\nThe codegen module converts the BlueTac IR to an x86_64 …\nThe <code>compiler_driver</code> module defines the functions and types …\nThe <code>ir</code> module is responsible for lowering the C AST into …\nThe <code>lexer</code> module handles the lexical analysis of the …\nThe <code>parser</code> module parses the stream of tokens produced by …\nThe <code>sema</code> module is responsible for semantic analysis of …\nThe <code>utils</code> module provides common utilities for the various …\nGenerates the assembly code for the given IR program and …\nA file containing assembly code.\nA file path returned by the compiler driver.\nThe BlueC compiler driver.\nAn error returned by the compiler driver.\nNo file was generated.\nEither an object file (‘.o’) or an executable binary …\nThe kind of warning.\nAdds a diagnostic (error or warning).\nA <code>HashSet</code> of all the warnings.\nA sorted <code>Vec</code> of the string representations of all the …\nThe <code>args</code> module defines the command-line argument parser. …\nEmits a warning that an array subscript index is out of …\nThe string representation of the warning kind.\nEmits a warning that the result of an assignment is used …\nEmits a warning that two different pointer types are being …\nEmits a warning that a pointer and an integer are being …\nEmits a warning that a ternary condition’s consequent …\nEmits an implicit conversion warning for a numeric …\nFor tests and debugging purposes, prints the diagnostics …\nThe <code>diagnostics</code> module defines errors and warnings emitted …\nAre diagnostics enabled?\nEmits a warning for a duplicate declaration specifier …\nReturns a <code>HashSet</code> of warnings that are enabled by default.\nThe number of error diagnostics.\nThe <code>errors</code> module defines all the error diagnostics.\nEmits a warning that an expression evaluated to zero and …\nEmits a warning about an ‘extern’ variable with an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the <code>Ok(WarningKind)</code> from its string …\nAre there any error diagnostics?\nEmits an implicit conversion warning for an arithmetic …\nEmits an implicit conversion warning for a switch …\nEmits a warning that an initializer string is too long for …\nEmits a warning that an integer literal is too large to be …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the given flag set in the options?\nEmits a warning that a subobject initializer is missing …\nEmits a warning that a declaration is missing its …\nEmits a warning that an expression has mixed operators and …\nThe <code>multi_file_driver</code> module provides functionality for …\nCreates a new compiler driver configured to compile the …\nThe <code>options</code> module defines the compiler driver’s options.\nThe compiler driver’s options.\nEmits a warning that a pointer is casted to an integer …\nEmits a warning that two pointers in an expression have …\nPrints all diagnostics to <code>stderr</code>, with any errors printed …\nPrints all diagnostics to the given <code>buffer</code>, with any …\nRuns the compiler pipeline and returns the appropriate …\nSets whether diagnostics are enabled.\nTurns a flag on.\nTakes ownership of the compiler driver’s options.\nThe <code>tempfile</code> module defines the <code>TempFile</code> type. This …\nEmits a warning that there are too many braces around an …\nEmits a warning that there are too many elements in the …\nEmits a warning that a variable is uninitialized.\nEmits a warning that a symbol is unused.\nThe number of warning diagnostics.\nThe command-line argument parser.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParses the command-line arguments into the compiler driver …\nA diagnostic emitted by the compiler.\nThe kind of diagnostic.\nA note that can be attached to a diagnostic.\nA diagnostic printer.\nAn identifier string and its source code location.\nAdds an additional source location to the diagnostic.\nAdds a note to the diagnostic.\nAdds a note to the diagnostic.\nConsumes the diagnostic and returns an equivalent with its …\nCreates an error diagnostic with the given error message.\nCreates an error diagnostic with the given error message …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of diagnostic.\nPrints all the diagnostics, with any errors printed first …\nSets whether to print in terse mode.\nSets whether to show the source filename and line:column …\nCreates a new warning diagnostic with the given message …\nCreates a new diagnostic printer.\nKinds of redefinition errors.\nEmits an error that there is an attempt to call an …\nEmits an error that a function type is not assignable\nEmits an error that an expression is being casted to a …\nEmits an error that a type specifier cannot be combined …\nEmits an error that an expression cannot be incremented or …\nEmits an error that an array must be initialized with an …\nEmits an error that an array cannot be initialized with a …\nEmits an error that the ‘&amp;’ operator cannot take the …\nEmits an error that an identifier is expected.\nEmits an error that a semicolon ‘;’ is expected at the …\nEmits an error that an expression is not assignable …\nReturns the argument unchanged.\nReturns the argument unchanged.\nEmits an error that a function has an invalid return type.\nEmits an error that a token is unexpected.\nEmits an error that a pointer cannot be converted to an …\nEmits an error that two function pointer types are …\nEmits an error that a pointer cannot be converted to an …\nEmits an error that two pointer types are incompatible …\nEmits an error that two types in an expression are …\nEmits an error that the ‘*’ operator requires a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmits an error that a binary operation has operands with …\nEmits an error that an expression cannot be called because …\nEmits an error that an expression cannot be cast to the …\nEmits an error that an integer or floating-point literal …\nEmits an error that the suffix is invalid on an integer or …\nEmits an error that a type specifier is invalid.\nEmits an error that a local extern variable cannot have an …\nEmits an error that a type specifier is missing.\nEmits an error that a symbol cannot be redefined to a …\nEmits an error that a function cannot be redefined with …\nEmits an error that a type alias cannot be redefined with …\nEmits an error that a variable cannot be redefined with …\nEmits an error that a variable cannot be redefined with a …\nEmits an error that a variable cannot be redefined with a …\nEmits an error that a token is unexpected.\nEmits an error that a type name is invalid.\nAn error returned by the multi-file compiler and linker.\nCompiles the given set of source files into object files …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA compiler driver flag specified on the command-line as ‘…\nOptions that control the compiler driver’s behavior.\nRun the lexer, parser, sema, IR translation, and assembly …\nFlags which were passed on the command-line as ‘-f’.\nReturns the argument unchanged.\nReturns the argument unchanged.\nOnly run preprocess, compiler, and assembler steps to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the given warning enabled?\nRun the lexer and then stop.\nLibraries to link with.\nObject files to link with.\nOnly run preprocess and compiler steps to produce an …\nThe file to write the output to, either an object file …\nRun the lexer and parser and then stop.\nDefine preprocessor macros.\nPrints the parsed AST and stops after parsing (before …\nPrints the BlueTac intermediate representation and stops …\nPrints the type-checked AST and stops after sema.\nRun the lexer, parser and semantic analysis and then stop.\nTreat warnings as errors.\nCreates the driver options with all warnings enabled.\nCreates the driver options with the default set of enabled …\nCreates the driver options with the default set of enabled …\nCreates the driver options with all warnings disabled.\nThe path to a temporary file.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>TempFile</code> path.\nThe <code>TempFile</code> path as a <code>&amp;str</code> string slice.\nThe <code>TempFile</code> path as a <code>String</code>.\nTries to create a unique temporary file path in the system…\nTries to create a unique temporary file path in the system…\nBinary operator.\nA constant arithmetic value.\nA BlueTac IR definition is either a function definition, a …\nThe IR for a function definition.\nA BlueTac IR instruction.\nA label identifier in IR.\nThe root of the BlueTac IR contains a list of definitions.\nThe IR for a global read-only constant value.\nAn initializer value for a static storage variable.\nThe IR for a variable with static storage duration.\nA case in a switch statement.\nAn IR data type.\nUnary operator.\nAn IR value is either a constant or a variable.\nA function definition\nA read-only constant value.\nA variable with static storage duration.\nThe size of the type in bits.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the IR type of the constant value.\nCreates a <code>BtConstantValue</code> for the current <code>BtType</code> with a …\nGets the type’s inner-most scalar type.\nGets the IR type of the value.\nIs the constant value the default zero?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this type an array type?\nIs this type a character (8-bit integer) type?\nIs this type a character array type?\nIs this type a floating-point type?\nIs this type a function type?\nIs this type an integer (signed or unsigned) type?\nIs this type a pointer type?\nIs this type a signed integer?\nIs this type an unsigned integer?\nIs the constant value equal to zero?\nMakes a <code>BtConstantValue</code> for the given type with a constant …\nConverts the <code>BtType</code> to a string suitable for the IR …\nLowers the C AST produced by the parser into BlueTac …\nA floating-point literal suffix.\nAn integer literal suffix.\nThe base of an integer or floating-point literal.\nThe location and span of a token in the source file.\nA token produced by lexical analysis.\nTypes of tokens produced by lexical analysis.\nThe base as an integer, e.g. <code>10</code> for <code>Decimal</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the token is an identifier, returns its string. …\nGets the next source location, of length 1, after this one.\nDoes the token have the given type?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDoes the token have one of the assignment token types?\nIs the token an identifier?\nIs the token an identifier with the given name?\nPerforms lexical analysis of the source translation unit …\nPerforms lexical analysis on the given <code>BufReader&lt;T&gt;</code>.\nMerges this and the <code>other</code> location into a new location, …\nCreates a new source location.\nMakes an identifier token type with the given name.\nSets this location’s length so that this location’s …\nInitialize a function pointer with the address of a …\nInitialize a pointer with the address of an object of …\nAn address constant is a null pointer, a pointer to an …\nAssignment operators.\nThe basic type of a declaration.\nA basic type specifier.\nBinary operators.\nFamilies or groups of binary operators.\nA block is a list of statements and declarations wrapped …\nAn item in a block can be a statement or a declaration.\nA constant floating-point value.\nA constant integer value.\nA constant value that was either parsed from a literal or …\nA declaration introduces a name and is either a variable …\nA parsed declarator.\nThe kind of declarator.\nAn <code>AstDeclaredType</code> represents a parsed type declaration …\nAn expression, which may in fact be a subexpression inside …\nThe kind of floating-point literal.\nA for-statement initializer can either be a variable …\nA full expression is an expression that is not a …\nA function declaration with optional definition.\nAn identifier is a user-defined name for variables, …\nThe kind of integer literal.\nThe linkage of an identifier determines the scope that it …\nAST metadata produced by the parser.\nA unique numerical identifier for a node in the AST.\nThe root of the AST, representing the file scope of the …\nA statement.\nA constant, compile-time initializer value for a static …\nA storage class specifier in a declaration.\nStorage class specifiers determine an identifier’s …\nThe storage duration of an identifier determines its …\nThe canonical type of an identifier.\nA <code>typedef</code> declaration.\nUnary operators.\nA unique string name for a variable, function, or type …\nA variable declaration with optional definition.\nA variable initializer.\nInitialize a pointer by casting from an integer value. …\nAn outer switch or loop statement which is in effect while …\nAn outer switch/loop statement which is in effect while we …\nContains the error value\nNull pointer constant. <code>int *p = 0;</code>.\nContains the success value\nAn error type signaling a parse error. The error is …\nThe result type returned by parsing functions.\nThe parser interprets tokens produced by the lexer to …\nA signed integer type that can hold the value of …\nEmits an error diagnostic with the given message.\nEmits an error diagnostic at the end of the source file.\nAdds source span metadata for a given node.\nAdds metadata about a switch <code>case</code> statement.\nAdds a <code>default</code> label to the given switch statement.\nReturns the name as a string slice.\nThe basic type of the declaration, from which the optional …\nThe size of this type in bits.\nCan the given <code>u64</code> value fit inside the range of values …\nConverts the constant value to a different type, …\nThe ID of the enclosing switch statement node, or None.\nThe <code>AstType</code> for the kind of integer literal.\nThe <code>AstType</code> for the kind of floating-point literal.\nThe optional declarator which augments the basic type …\nRuns the given closure without allowing any diagnostics to …\nReturns whether an expression is wrapped in parentheses in …\nThe family or group that the operator belongs to.\nCan all the values of this type fit inside the given <code>other</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMakes an <code>AstConstantInteger</code> with the appropriate …\nGets the AST type of the constant value.\nGets the AST type of the constant integer value.\nGets the AST type of the constant floating-point value.\nGets the common <code>AstType</code> for the given two types.\nGets the declared type of the declaration.\nGets the derived kind of the declarator. You probably want …\nGets the identifier if the declarator has one, or returns …\nIf the declared type has a declarator, and if that …\nGets the metadata for the given identifier, if the …\nGets the metadata for the given identifier, if the …\nGets the type’s inner-most scalar type.\nGets a node’s data type.\nGets source span metadata for a given node.\nGets source span metadata for a given node and returns it …\nGets the <code>case</code> statement values and node ids for the given …\nDoes the identifier have linkage?\nIs the constant value below zero? Always false for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this declarator an abstract array? (Array with no …\nIs this type an aggregate type?\nIs this type an arithmetic type (integer, boolean, or …\nIs the AST expression an arithmetic (integer or …\nIs this type an array type?\nIs this type a ‘basic type’?\nIs this type a character type?\nIs this type an array of a character type?\nIs the operator a compound assignment operator?\nReturns <code>true</code> if the unique name string has a length of …\nIs this storage class specifier ‘extern’?\nIs this type a floating-point type?\nIs this declarator a function declarator?\nIs this type a function type? (Not a function pointer.)\nIs this type a function pointer type?\nIs this type an integral type?\nIs the AST expression an integer literal?\nIs the AST expression an integer literal with the given …\nIs the AST expression an l-value?\nIs this type a pointer type?\nIs the operator a relational operator?\nHas the declared type been resolved?\nIs this type a scalar type?\nIs this type a signed integer?\nIs this storage class specifier ‘static’?\nIs the AST expression a string literal?\nIs this storage class specifier ‘typedef’?\nIs this type an unsigned integer?\nIs the constant value equal to zero?\nIs the constant integer value equal to zero?\nThe kind of declarator. You probably want …\nReturns the length of the unique name string, in bytes.\nCreates a new parser which consumes the given vector of …\nCreates a new, unique <code>AstNodeId</code>.\nMakes a new <code>AstDeclarator</code>\nCreates an identifier.\nCreates an <code>AstUniqueName</code> from a string that must be …\nCreates a new full expression which takes ownership of the …\nCreates the AST metadata.\nCreates a new array type.\nCreates a new function type.\nCreates a new <code>AstExpression:IntegerLiteral</code> with the given …\nCreates a new pointer type to the given <code>AstType</code>.\nGets the initializer’s node id.\nGets the node ID for the AST expression.\nCreates a null sentinel value for an <code>AstNodeId</code>.\nParses the stream of tokens produced by the lexer and …\nThe <code>printer</code> module is used by the parent parser module to …\nPromotes a small integer type (‘_Bool’, ‘char’, or …\nCreates a new, resolved <code>AstDeclaredType</code>.\nThe resolved, canonical <code>AstType</code>. The semantic analysis …\nRuns the given closure and then restores the TokenStream …\nDoes this type have the same signedness as the <code>other</code> type?\nRecords that an expression is wrapped in parentheses in …\nSets the data type of a node. This either adds or updates …\nOptional storage class specifier.\nDoes the given switch statement have a <code>default</code> label?\nThe <code>symbol</code> module defines the <code>SymbolKind</code> enum.\nCreates a C declarator string representation of the given …\nMakes an unsigned integer version of the current integer …\nCreates a new, unresolved <code>AstDeclaredType</code>.\nRuns the given closure after capturing the id of the …\nRuns the given closure after creating a new Symbol Table …\nPrints the AST with indentation\nKinds of symbols\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>constant_eval</code> module provides functionality to …\nThe <code>constant_table</code> module defines the <code>ConstantTable</code> type, …\nAnalyzes the C AST produced by the Parser for semantic …\nThe <code>symbol_table</code> module defines the <code>SymbolTable</code> type and …\nThe <code>type_conversion</code> module provides functionality to …\nThe <code>type_resolution</code> module provides functionality to …\nThe context to use for constant expression evaluation.\nEvaluates an AST expression node at compile-time and …\nEvaluates an AST full expression node at compile-time and …\nReturns the argument unchanged.\nCreates the constant evaluation context from the given …\nGets a node’s data type\nCalls <code>U::from(self)</code>.\nCreates a new constant evaluation context.\nA floating-point entry in the Constant Table.\nA unique index for a constant value in the constant table.\nA string entry in the Constant Table.\nA table of constant values.\nThe constant value.\nThe constant floating-point value as an unsigned integer.\nAdds a new <code>f32</code> constant to the table and returns its …\nAdds a new <code>f64</code> constant to the table and returns its …\nAdds a new string constant to the table and returns its …\nAdds a new constant array of strings to the table for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the value for the constant at the given index.\nReturns the value for the given constant.\nReturns a vector of all the floating point constants.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the table contains no entries.\nThe number of entries in the table.\nCreates a symbol name for the given constant index.\nCreates a new constant table.\nMetadata about an identifier’s definition.\nErrors returned by <code>SymbolTable::set_definition</code>.\nMetadata about a symbol.\nSymbol attributes.\nThe Symbol Table records metadata about identifiers.\nAdds a symbol to the table.\nCreates symbol attributes for a constant.\nThe name of the symbol as it was declared in the source …\nCreates symbol attributes for a file scope variable.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates symbol attributes for a function.\nReturns the symbol for the given unique identifier name, …\nReturns a vector of all unused variable and function …\nDoes the symbol have internal or external linkage?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the symbol defined?\nThe kind of symbol.\nThe symbol’s linkage.\nCreates symbol attributes for a local variable.\nThe source location of the symbol’s declaration.\nCreates a new symbol table.\nSets that a symbol is defined.\nSets that the symbol has been used.\nThe symbol’s storage duration.\nCreates symbol attributes for a type alias.\nCasts a <code>i128</code> value to the given integer data type, and …\nConverts an <code>i32</code> value to an <code>i16</code>.\nConverts an <code>i64</code> value to an <code>i16</code>.\nConverts an <code>i64</code> value to an <code>i32</code>.\nConverts a <code>u64</code> value to an <code>i16</code>.\nConverts a <code>u64</code> value to an <code>i32</code>.\nConverts a <code>u64</code> value to an <code>i64</code>.\nConverts a <code>u64</code> value to an <code>i8</code>.\nConverts a <code>u64</code> value to a <code>u16</code>.\nConverts a <code>u64</code> value to a <code>u32</code>.\nConverts a <code>u64</code> value to a <code>u8</code>.\nAn error returned by <code>resolve_type</code>. Error diagnostics are …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nResolves the given <code>AstDeclaredType</code> to its canonical <code>AstType</code>…\nThe <code>string</code> module provides common string utilities.\nConverts an integer value to an ASCII string.")