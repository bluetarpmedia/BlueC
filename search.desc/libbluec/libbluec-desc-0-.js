searchState.loadedDescShard("libbluec", 0, "The BlueC library.\nGenerates an internal compiler error.\nThe codegen module converts the BlueTac IR to an x86_64 …\nThe compiler_driver module defines the wrapper tool that …\nThe <code>ir</code> module is responsible for lowering the C AST into …\nThe <code>lexer</code> module handles the lexical analysis of the …\nThe parser module parses the stream of tokens produced by …\nThe <code>sema</code> module is responsible for semantic analysis of …\nGenerates the assembly code for the given IR program and …\nA file containing assembly code.\nA file path returned by the compiler driver.\nThe BlueC compiler driver.\nAn error returned by the compiler driver.\nNo file was generated.\nEither an object file (‘.o’) or an executable binary …\nAdds a diagnostic (error or warning).\nThe <code>args</code> module defines the command-line argument parser. …\nFor tests and debugging purposes, prints the diagnostics …\nThe diagnostics module defines errors and warnings emitted …\nAre diagnostics enabled?\nThe number of error diagnostics.\nThe <code>errors</code> module defines all the error diagnostics.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAre there any error diagnostics?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the given flag set in the options?\nThe <code>multi_file_driver</code> module provides functionality for …\nCreates a new compiler driver configured to compile the …\nThe <code>options</code> module defines the compiler driver’s options.\nThe compiler driver’s options.\nPrints all diagnostics to <code>stderr</code>, with any errors printed …\nPrints all diagnostics to the given <code>buffer</code>, with any …\nRuns the compiler pipeline and returns the appropriate …\nSets whether diagnostics are enabled.\nTurns a flag on.\nTakes ownership of the compiler driver’s options.\nThe <code>tempfile</code> module defines the <code>TempFile</code> type. This …\nThe number of warning diagnostics.\nThe <code>warnings</code> module defines all the warning diagnostics.\nThe command-line argument parser.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParses the command-line arguments into the compiler driver …\nA diagnostic emitted by the compiler.\nThe kind of diagnostic.\nA note that can be attached to a diagnostic.\nA diagnostic printer.\nAn identifier string and its source code location.\nAdds an additional source location to the diagnostic.\nAdds a note to the diagnostic.\nAdds a note to the diagnostic.\nConsumes the diagnostic and returns an equivalent with its …\nCreates an error diagnostic with the given error message.\nCreates an error diagnostic with the given error message …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe kind of diagnostic.\nPrints all the diagnostics, with any errors printed first …\nSets whether to print in terse mode.\nSets whether to show the source filename and line:column …\nCreates a new warning diagnostic with the given message …\nCreates a new diagnostic printer.\nKinds of redefinition errors.\nEmits an error that there is an attempt to call an …\nEmits an error that an expression is being casted to a …\nEmits an error that a type specifier cannot be combined …\nEmits an error that the ‘&amp;’ operator cannot take the …\nEmits an error that an identifier is expected.\nEmits an error that a semicolon ‘;’ is expected at the …\nEmits an error that an expression is not assignable …\nReturns the argument unchanged.\nReturns the argument unchanged.\nEmits an error that a token is unexpected.\nEmits an error that a pointer cannot be converted to an …\nEmits an error that a pointer cannot be converted to an …\nEmits an error that two pointer types are incompatible …\nEmits an error that two types in an expression are …\nEmits an error that the ‘*’ operator requires a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmits an error that a binary operation has operands with …\nEmits an error that an expression cannot be cast to the …\nEmits an error that an integer or floating-point literal …\nEmits an error that the suffix is invalid on an integer or …\nEmits an error that a type specifier is invalid.\nEmits an error that a local extern variable cannot have an …\nEmits an error that a type specifier is missing.\nEmits an error that a symbol cannot be redefined to a …\nEmits an error that a function cannot be redefined with …\nEmits an error that a type alias cannot be redefined with …\nEmits an error that a variable cannot be redefined with …\nEmits an error that a variable cannot be redefined with a …\nEmits an error that a variable cannot be redefined with a …\nEmits an error that a token is unexpected.\nEmits an error that a type name is invalid.\nAn error returned by the multi-file compiler and linker.\nCompiles the given set of source files into object files …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA compiler driver flag specified on the command-line as ‘…\nOptions that control the compiler driver’s behavior.\nRun the lexer, parser, sema, IR translation, and assembly …\nFlags which were passed on the command-line as ‘-f’.\nReturns the argument unchanged.\nReturns the argument unchanged.\nOnly run preprocess, compiler, and assembler steps to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun the lexer and then stop.\nLibraries to link with.\nObject files to link with.\nOnly run preprocess and compiler steps to produce an …\nThe file to write the output to, either an object file …\nRun the lexer and parser and then stop.\nDefine preprocessor macros.\nPrints the parser’s output (the abstract syntax tree) …\nPrints the BlueTac intermediate representation and stops …\nRun the lexer, parser and semantic analysis and then stop.\nTreat warnings as errors.\nEnable warnings.\nThe path to a temporary file.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>TempFile</code> path.\nThe <code>TempFile</code> path as a <code>&amp;str</code> string slice.\nThe <code>TempFile</code> path as a <code>String</code>.\nTries to create a unique temporary file path in the system…\nTries to create a unique temporary file path in the system…\nEmits a warning that the result of an assignment is used …\nEmits a warning that two different pointer types are being …\nEmits a warning that a pointer and an integer are being …\nEmits a warning that a ternary condition’s consequent …\nEmits a warning for a duplicate declaration specifier …\nEmits a warning that an expression evaluated to zero and …\nEmits a warning about an ‘extern’ variable with an …\nReturns the argument unchanged.\nEmits an implicit conversion warning, optionally with a …\nEmits an implicit conversion warning for a switch …\nEmits a warning that an integer literal is too large to be …\nCalls <code>U::from(self)</code>.\nEmits a warning that a declaration is missing its …\nEmits a warning that an expression has mixed operators and …\nEmits a warning that two pointers in an expression have …\nEmits a warning that a variable is uninitialized.\nEmits a warning that a symbol is unused.\nBinary operator.\nA constant integer or floating-point value.\nA BlueTac IR definition is either a function definition or …\nThe IR for a function definition.\nA BlueTac IR instruction.\nA label identifier in IR.\nThe root of the BlueTac IR contains a list of definitions.\nThe IR for a variable with static storage duration.\nA case in a switch statement.\nAn IR data type.\nUnary operator.\nAn IR value is either a constant or a variable.\nThe size of the type in bits.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the IR type of the constant value.\nCreates a <code>BtConstantValue</code> for the current <code>BtType</code> with a …\nGets the IR type of the value.\nIs the constant value the default zero?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this type a floating-point type?\nIs this type an integer (signed or unsigned) type?\nIs this type a signed integer?\nIs this type an unsigned integer?\nMakes a <code>BtConstantValue</code> for the given type with a constant …\nTranslates the C AST produced by the parser into BlueTac …\nA floating-point literal suffix.\nAn integer literal suffix.\nThe base of an integer or floating-point literal.\nThe location and span of a token in the source file.\nA token produced by lexical analysis.\nTypes of tokens produced by lexical analysis.\nThe base as an integer, e.g. <code>10</code> for <code>Decimal</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the token is an identifier, returns its string. …\nGets the next source location, of length 1, after this one.\nDoes the token have one of the assignment token types?\nDoes the token have the given type?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the token an identifier?\nIs the token an identifier with the given name?\nPerforms lexical analysis of the source translation unit …\nPerforms lexical analysis on the given <code>BufReader&lt;T&gt;</code>.\nMakes an identifier token type with the given name.\nMerges this and the <code>other</code> location into a new location, …\nCreates a new source location.\nSets this location’s length so that this location’s …\nThe basic type of a declaration.\nA basic type specifier.\nBinary operators.\nFamilies or groups of operators.\nA block is a list of statements and declarations wrapped …\nAn item in a block can be a statement or a declaration.\nA constant floating-point value.\nA constant integer value.\nA constant initializer expression for a pointer type.\nA constant integer or floating-point value.\nA declaration introduces a name and is either a variable …\nA parsed declarator.\nThe kind of declarator.\nA basic type, optional storage class specifier, and …\nAn expression, which may in fact be a subexpression inside …\nThe kind of floating-point literal.\nA for-statement initializer can either be a variable …\nA full expression is an expression that is not a …\nA function declaration with optional definition.\nAn identifier is a user-defined name for variables, …\nThe kind of integer literal.\nThe linkage of an identifier determines the scope that it …\nAST metadata produced by the parser.\nA unique numerical identifier for a node in the AST.\nThe root of the AST, representing the file scope of the …\nA statement.\nA storage class specifier in a declaration.\nStorage class specifiers determine an identifier’s …\nThe storage duration of an identifier determines its …\nThe canonical type of an identifier.\nA <code>typedef</code> declaration.\nUnary operators.\nA unique string name for a variable, function, or type …\nA variable declaration with optional definition.\nAn outer switch or loop statement which is in effect while …\nAn outer switch/loop statement which is in effect while we …\nContains the error value\nContains the success value\nAn error type signaling a parse error. The error is …\nThe result type returned by parsing functions.\nThe parser interprets tokens produced by the lexer to …\nEmits an error diagnostic with the given message.\nEmits an error diagnostic at the end of the source file.\nAdds source span metadata for a given node.\nAdds metadata about a switch <code>case</code> statement.\nAdds a <code>default</code> label to the given switch statement.\nReturns the name as a string slice.\nThe basic type of the declaration, from which the optional …\nThe size of the type in bits.\nCan the given <code>u64</code> value fit inside the range of values …\nConverts the constant value to a different type, …\nThe ID of the enclosing switch statement node, or None.\nThe <code>AstType</code> for the kind of integer literal.\nThe <code>AstType</code> for the kind of floating-point literal.\nThe optional declarator which augments the basic type …\nRuns the given closure without allowing any diagnostics to …\nThe <code>expr</code> module defines the various parsing functions for …\nReturns whether an expression is wrapped in parentheses in …\nThe family or group that the operator belongs to.\nCan all the values of this type fit inside the given <code>other</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMakes an <code>AstConstantInteger</code> with the appropriate …\nGets the AST type of the constant integer value.\nGets the AST type of the constant floating-point value.\nGets the AST type of the constant value.\nGets the common <code>AstType</code> for the given two types.\nGets the declared type of the declaration.\nGets the derived kind of the declarator. You probably want …\nGets the identifier if the declarator has one, or returns …\nIf the declared type has a declarator, and if that …\nGets the metadata for the given identifier, if the …\nGets the metadata for the given identifier, if the …\nGets a node’s data type.\nGets source span metadata for a given node.\nGets source span metadata for a given node and returns it …\nGets the <code>case</code> statement values and node ids for the given …\nDoes the identifier have linkage?\nIs the constant value below zero? Always false for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the type an arithmetic type (integer, boolean, or …\nIs this type a ‘basic type’?\nIs the binary operator a compound assignment operator?\nReturns <code>true</code> if the unique name string has a length of …\nIs this storage class specifier ‘extern’?\nIs the type a floating-point type?\nIs this declarator a function declarator?\nIs the type a function type? (Not a function pointer.)\nIs the type an integral type?\nIs the AST expression an integer literal?\nIs the AST expression an l-value?\nIs the type a pointer type?\nIs the binary operator a relational operator?\nHas the declared type been resolved?\nIs this type a signed integer?\nIs this storage class specifier ‘static’?\nIs this storage class specifier ‘typedef’?\nIs this type an unsigned integer?\nIs the constant value equal to zero?\nThe kind of declarator. You probably want …\nReturns the length of the unique name string, in bytes.\nCreates a new parser which consumes the given vector of …\nCreates a new, unique <code>AstNodeId</code>.\nMakes a new <code>AstDeclarator</code>\nCreates an identifier.\nCreates an <code>AstUniqueName</code> from a string that must be …\nCreates the AST metadata.\nCreates a new function type.\nCreates a new pointer type to the given <code>AstType</code>.\nGets the node ID for the AST expression.\nCreates a null sentinel value for an <code>AstNodeId</code>.\nParses the stream of tokens produced by the lexer and …\nThe <code>printer</code> module is used by the parent parser module to …\nPromotes a small integer type (‘_Bool’, ‘char’, or …\nCreates a new, resolved <code>AstDeclaredType</code>.\nThe resolved, canonical <code>AstType</code>. The semantic analysis …\nRuns the given closure and then restores the TokenStream …\nDoes this type have the same signedness as the <code>other</code> type?\nRecords that an expression is wrapped in parentheses in …\nSets the data type of a node. This either adds or updates …\nOptional storage class specifier.\nDoes the given switch statement have a <code>default</code> label?\nThe <code>symbol</code> module defines the <code>SymbolKind</code> enum.\nMakes an unsigned integer version of the current integer …\nCreates a new, unresolved <code>AstDeclaredType</code>.\nRuns the given closure after capturing the id of the …\nRuns the given closure after creating a new Symbol Table …\nThe binary_ops module defines some helper functions for …\nParses a tree of (sub)expression(s).\nParses a factor.\nParses a full expression.\nAttempts to parse a full expression unless the very next …\nReturns the precedence integer value for the given binary …\nIs the token a binary operator?\nParses a token and produces an AST binary operator.\nPrints the AST with indentation\nKinds of symbols\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAnalyzes the C AST produced by the Parser for semantic …\nThe <code>symbol_table</code> module defines the <code>SymbolTable</code> type and …\nThe <code>type_conversion</code> module provides functionality to …\nThe <code>type_resolution</code> module provides functionality to …\nMetadata about an identifier’s definition.\nErrors returned by <code>SymbolTable::set_definition</code>.\nMetadata about a symbol.\nSymbol attributes.\nThe Symbol Table records metadata about identifiers.\nAdds a symbol to the table.\nThe name of the symbol as it was declared in the source …\nCreates symbol attributes for a file scope variable.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates symbol attributes for a function.\nReturns the symbol for the given unique identifier name, …\nReturns a vector of all unused variable and function …\nDoes the symbol have internal or external linkage?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the symbol defined?\nThe kind of symbol.\nThe symbol’s linkage.\nCreates symbol attributes for a local variable.\nThe source location of the symbol’s declaration.\nCreates a new symbol table.\nSets that a symbol is defined.\nSets that the symbol has been used.\nThe symbol’s storage duration.\nCreates symbol attributes for a type alias.\nCasts a <code>i128</code> value to the given integer data type, and …\nConverts an <code>i32</code> value to an <code>i16</code>.\nConverts an <code>i64</code> value to an <code>i16</code>.\nConverts an <code>i64</code> value to an <code>i32</code>.\nConverts a <code>u64</code> value to an <code>i32</code>.\nConverts a <code>u64</code> value to an <code>i64</code>.\nConverts a <code>u64</code> value to a <code>u32</code>.\nAn error returned by <code>resolve_type</code>. Error diagnostics are …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nResolves the given <code>AstDeclaredType</code> to its canonical <code>AstType</code>…")